import mysql.connector
from mysql.connector import Error
from config import DB_CONFIG
import logging
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Database:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Database, cls).__new__(cls)
            cls._instance.connection = None
        return cls._instance

    def connect(self):
        try:
            if self.connection is None or not self.connection.is_connected():
                # Verify SSL certificate exists
                if not os.path.exists(DB_CONFIG['ssl_ca']):
                    raise FileNotFoundError(f"SSL CA certificate not found at {DB_CONFIG['ssl_ca']}")
                
                # Create connection with SSL
                self.connection = mysql.connector.connect(
                    host=DB_CONFIG['host'],
                    port=DB_CONFIG['port'],
                    user=DB_CONFIG['user'],
                    password=DB_CONFIG['password'],
                    database=DB_CONFIG['database'],
                    ssl_ca=DB_CONFIG['ssl_ca'],
                    ssl_verify_cert=DB_CONFIG['ssl_verify_cert']
                )
                logger.info("Successfully connected to MySQL database with SSL")
        except Error as e:
            logger.error(f"Error connecting to MySQL database: {e}")
            raise

    def disconnect(self):
        if self.connection and self.connection.is_connected():
            self.connection.close()
            logger.info("Database connection closed")

    def execute_query(self, query, params=None):
        try:
            self.connect()
            cursor = self.connection.cursor(dictionary=True)
            cursor.execute(query, params or ())
            result = cursor.fetchall()
            cursor.close()
            return result
        except Error as e:
            logger.error(f"Error executing query: {e}")
            raise
        finally:
            self.disconnect()


    def execute_update(self, query, params=None):
        try:
            self.connect()
            cursor = self.connection.cursor()
            cursor.execute(query, params or ())
            self.connection.commit()
            affected_rows = cursor.rowcount
            cursor.close()
            return affected_rows
        except Error as e:
            logger.error(f"Error executing update: {e}")
            self.connection.rollback()
            raise
        finally:
            self.disconnect()

    def execute_update_version2(self, query, params=None):
        """
        Execute an UPDATE, INSERT, or DELETE query with improved error handling and connection management.
        
        Args:
            query (str): The SQL query to execute
            params (tuple/list, optional): Parameters for the query
            
        Returns:
            dict: A dictionary containing:
                - affected_rows (int): Number of rows affected
                - lastrowid (int/None): ID of the last inserted row (for INSERT)
                - query_type (str): Type of query executed ('INSERT', 'UPDATE', 'DELETE')
                
        Raises:
            Error: Database errors are logged and re-raised
        """
        cursor = None
        try:
            # Connect to database
            self.connect()
            cursor = self.connection.cursor()
            
            # Determine query type for better logging
            query_type = 'UNKNOWN'
            query_upper = query.strip().upper()
            if query_upper.startswith('INSERT'):
                query_type = 'INSERT'
            elif query_upper.startswith('UPDATE'):
                query_type = 'UPDATE'
            elif query_upper.startswith('DELETE'):
                query_type = 'DELETE'
                
            logger.info(f"Executing {query_type} query: {query}")
            if params:
                logger.info(f"Query parameters: {params}")
                
            # Execute query
            cursor.execute(query, params or ())
            self.connection.commit()
            
            # Get results
            affected_rows = cursor.rowcount
            lastrowid = cursor.lastrowid if query_type == 'INSERT' else None
            
            result = {
                "affected_rows": affected_rows,
                "lastrowid": lastrowid,
                "query_type": query_type
            }
            
            logger.info(f"Query executed successfully. {query_type} affected {affected_rows} rows")
            if lastrowid:
                logger.info(f"Last inserted row ID: {lastrowid}")
                
            return result
            
        except Error as e:
            logger.error(f"Database error executing {query_type} query: {str(e)}", exc_info=True)
            logger.error(f"Failed query: {query}")
            if params:
                logger.error(f"Query parameters: {params}")
            self.connection.rollback()
            raise ValueError(f"Database operation failed: {str(e)}")
            
        except Exception as e:
            logger.error(f"Unexpected error executing query: {str(e)}", exc_info=True)
            self.connection.rollback()
            raise ValueError(f"Unexpected error during database operation: {str(e)}")
            
        finally:
            if cursor:
                try:
                    cursor.close()
                except Exception as e:
                    logger.error(f"Error closing cursor: {str(e)}")
            try:
                self.disconnect()
            except Exception as e:
                logger.error(f"Error disconnecting from database: {str(e)}")

    def execute_transaction(self, queries):
        """
        Execute multiple queries in a single transaction.
        
        Args:
            queries (list): List of dictionaries, each containing:
                {
                    'query': str,  # The SQL query to execute
                    'params': tuple/list,  # Parameters for the query (optional)
                    'type': str  # Type of query ('INSERT', 'UPDATE', 'DELETE')
                }
                
        Returns:
            dict: A dictionary containing:
                - results (list): List of results for each query
                - transaction_success (bool): Whether all queries succeeded
                - lastrowid (int/None): ID of the last inserted row (if any)
                
        Raises:
            ValueError: If any query fails, the entire transaction is rolled back
        """
        cursor = None
        results = []
        
        try:
            # Connect to database
            self.connect()
            cursor = self.connection.cursor()
            
            # Start transaction
            cursor.execute("START TRANSACTION")
            
            for query_info in queries:
                query = query_info['query']
                params = query_info.get('params')
                query_type = query_info.get('type', 'UNKNOWN')
                
                logger.info(f"Executing {query_type} query: {query}")
                if params:
                    logger.info(f"Query parameters: {params}")
                
                # Execute query
                cursor.execute(query, params or ())
                
                # Get results for this query
                result = {
                    "affected_rows": cursor.rowcount,
                    "lastrowid": cursor.lastrowid if query_type == 'INSERT' else None,
                    "query_type": query_type
                }
                results.append(result)
                
                logger.info(f"Query executed successfully. {query_type} affected {result['affected_rows']} rows")
                if result['lastrowid']:
                    logger.info(f"Last inserted row ID: {result['lastrowid']}")
            
            # If all queries succeeded, commit the transaction
            self.connection.commit()
            logger.info("Transaction committed successfully")
            
            return {
                "results": results,
                "transaction_success": True,
                "lastrowid": results[-1]['lastrowid'] if results else None
            }
            
        except Error as e:
            logger.error(f"Database error in transaction: {str(e)}", exc_info=True)
            logger.error("Failed queries:")
            for query_info in queries:
                logger.error(f"Query: {query_info['query']}")
                if query_info.get('params'):
                    logger.error(f"Parameters: {query_info['params']}")
            self.connection.rollback()
            raise ValueError(f"Transaction failed: {str(e)}")
            
        except Exception as e:
            logger.error(f"Unexpected error in transaction: {str(e)}", exc_info=True)
            self.connection.rollback()
            raise ValueError(f"Unexpected error during transaction: {str(e)}")
            
        finally:
            if cursor:
                try:
                    cursor.close()
                except Exception as e:
                    logger.error(f"Error closing cursor: {str(e)}")
            try:
                self.disconnect()
            except Exception as e:
                logger.error(f"Error disconnecting from database: {str(e)}")    
    
    def initialize_tables(self):
        """Initialize database tables if they don't exist"""
        create_tables_queries = [
            """
            CREATE TABLE IF NOT EXISTS accounts (
                account_id VARCHAR(36) PRIMARY KEY,
                account_type VARCHAR(20) NOT NULL,
                balance DECIMAL(15,2) NOT NULL,
                currency VARCHAR(3) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS beneficiaries (
                beneficiary_id VARCHAR(36) PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                account_number VARCHAR(50) NOT NULL,
                bank_code VARCHAR(20) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS payments (
                payment_id VARCHAR(36) PRIMARY KEY,
                amount DECIMAL(15,2) NOT NULL,
                currency VARCHAR(3) NOT NULL,
                beneficiary_id VARCHAR(36) NOT NULL,
                source_account_id VARCHAR(36) NOT NULL,
                status VARCHAR(20) NOT NULL,
                type VARCHAR(20) NOT NULL,
                scheduled_date TIMESTAMP NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                completed_at TIMESTAMP NULL,
                FOREIGN KEY (beneficiary_id) REFERENCES beneficiaries(beneficiary_id)
            )
            """
        ]

        try:
            self.connect()
            cursor = self.connection.cursor()
            for query in create_tables_queries:
                cursor.execute(query)
            self.connection.commit()
            cursor.close()
            logger.info("Database tables initialized successfully")
        except Error as e:
            logger.error(f"Error initializing tables: {e}")
            self.connection.rollback()
            raise
        finally:
            self.disconnect()

# Create a singleton instance
db = Database() 